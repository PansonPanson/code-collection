# 操作系统漫游记003之程序的机器级表示part3内存越界引用与缓冲区溢出

C对数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存的寄存器值和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，视图重新加载寄存器或执行ret指令时，就会出现很严重的错误.

一种特别常见的状态破坏称为缓冲区溢出（buffer overflow）。通常，在栈中分配某个字符数组来保存一个字符串，但是该字符串的长度超过了为数组分配的空间。实例程序就说明了这个问题：

```c
/* Implementation of library function gets() */
char*gets(char*s)
{
    int c;
    char*dest=s;
    while((c=getchar())!= ’\n’ &&c!=EOF)
        *dest++=c;
    if(c==EOF&&dest==s)
        /* No characters read */
        return NULL;
    *dest++= ’\0’; /* Terminate string */
    return s;
}

/* Read input line and write it back */
void echo()
{
    char buf[8]; /* Way too small! */
    gets(buf);
    puts(buf);
}

```

**攻击代码：**

缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络估计系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击代码（exploit code），另外，还有一些字节会用一个指向估攻击代码的指针覆盖返回地址。

**缓冲区溢出攻击的解决策略：**

+ 栈随机化

    栈随机化的思想使得栈在每次运行时位置都产生变化。攻击者插入攻击代码时，也要插入指向这段代码的指针，这个指针也是攻击代码的一部分，产生这个指针就需要这个字符串放置的栈指针。在过去，程序的栈地址非常容易预测。

+ 栈破坏检测

    d第二道防线：检测何时栈已经被破坏。

+ 限制可执行代码区域

    最后一招是消除攻击者向系统中插入可执行代码的能力，其中一种实现方法就是限制哪些内存区域能够存放可执行代码。通常在程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的，其他部分可以被限制为只允许读和写。
