

# 高并发之扩容

+ 垂直扩容（纵向扩展）：提高系统部件能力
+ 水平扩容（横向扩展）：增加更多系统成员来实现

## 扩容 - 数据库

+ 读操作扩展：memcache、redis、CDN等缓存
+ 写操作扩展：Cassandra、Hbase等



# 高并发之缓存

## 缓存特征

+ 命中率：命中数 / (命中数 + 没有命中数)
+ 最大元素（空间）
+ 清空策略：FIFO、LFU、LRU、过期时间、随机等

## 缓存命中率影响因素

+ 业务场景和业务需求
  + 实时性要求越低越适合缓存
+ 缓存的设计（粒度和策略）
+ 缓存容量和基础设施

## 缓存分类和应用场景

+ 本地缓存：编程实现（成员变量、局部变量、静态变量）、Guava Cache
+ 分布式缓存：Memcache、Redis

## 高并发场景下缓存常见问题

+ 缓存一致性
  + 更新数据库成功 —> 更新缓存失败 —> 数据不一致
  + 更新缓存成功 —> 更新数据库失败 —> 数据不一致
  + 更新数据库成功 —>淘汰缓存失败 —> 数据不一致
  + 淘汰缓存成功 —> 更新数据库失败 —> 查询缓存miss
+ 缓存并发问题
  + 缓存过期后，直接从数据库拿数据，高并发情况下，对数据库产生了极大冲击，甚至导致雪崩问题
  + 使用锁机制解决，更新操作加锁，其他操作只需牺牲一定的等待时间即可直接从缓存中得到数据
+ 缓存穿透问题
  + 在高并发场景下,如果某个key被高并发地访问并没有命中，出于容错性的考虑，会尝试从后端获取，从而导致大量的请求达到数据库，而如果对应的value是空的时候，就导致了很多不必要的查询操作，从而导致了数据库的巨大压力
  + 解决方法：
    + 缓存空对象
    + 单独过滤处理，空对象单独缓存，请求时进行拦截处理
+ 缓存的雪崩现象
  + 缓存颠簸（抖动）比雪崩轻微



# 消息队列

## 消息队列特性

+ 业务无关
+ FIFO: 先投递先送达
+ 容灾: 节点的动态增删和消息的持久化
+ 性能：吞吐量提升，系统内部通信效率提高

## 为什么需要消息队列

+ [生产]和[消费]的速度或稳定性等因素不一致

## 消息队列好处

+ 业务解耦
+ 最终一致性
+ 广播
+ 错峰与流控



# 应用拆分

## 应用拆分 - 原则

+ 业务优先
+ 循序渐进
+ 兼顾技术：重构、分层
+ 可靠测试

## 应用拆分 - 思考

+ 应用之间通信：RPC(dubbo等)、消息队列
+ 应用之间数据库设计：每个应用都有独立的数据库
+ 避免事务操作跨应用

